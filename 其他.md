## 20

## 1 操作系统中进程和线程怎么通信

- 读写锁
- 互斥锁
- 管道
- 消息队列

## 3 JSBridge 基本原理 / js 与 native 怎么通信？

js 调用 native

1. 理论上，无论是 iOS 还是 Android，提供的 WebView 容器是可以拦截一切 H5 发起的请求的，无论是标准协议（如 http://、https:// 等）还是私有协议（如 weixin:// ）。基于这个原理，H5 采用私有协议模拟发起 URL 请求，Native 解析这类 URL 并定制相应的处理函数，这就实现了 H5 调用 Native。
2. 在 Native 的开发中，开发者可以给 WebView 容器注入全局变量并挂载在 window 对象上，这样前端 js 就可以通过 window 上全局对象方法 来调用一些 Native 的方法。这里需要注意的是方法注入的时机，一般是 WebView 一旦加载页面就需要注入变量。

native 调用 js
给 WebView 容器注入全局变量并挂载在 window 对象上，实际上是 Native 代码执行了一个 evaluateJavaScript 函数，直接运行 js 字符串代码(类似 js 的 eval 函数)，从而实现注入。所以 Native 代码也一样可以通过这个 evaluateJavaScript 函数来调用约定好的 js 函数来实现 H5 的调用。

基础流程
------------------------私有协议--------------------------------
H5 <----> JSBridage(js) <----> JSBridage(java/oc) <----> java/oc
--------------------evaluateScript-----------------------------



## 9 Puppeteer 是什么

Puppeteer 是 Node.js 工具引擎
Puppeteer 提供了一系列 API，通过 Chrome DevTools Protocol 协议控制 Chromium/Chrome 浏览器的行为
Puppeteer 默认情况下是以 headless 启动 Chrome 的，也可以通过参数控制启动有界面的 Chrome
Puppeteer 默认绑定最新的 Chromium 版本，也可以自己设置不同版本的绑定
Puppeteer 让我们不需要了解太多的底层 CDP 协议实现与浏览器的通信

- 网页截图或者生成 PDF
- 爬取 SPA 或 SSR 网站
- UI 自动化测试，模拟表单提交，键盘输入，点击等行为
- 捕获网站的时间线，帮助诊断性能问题
- 创建一个最新的自动化测试环境，使用最新的 js 和最新的 Chrome 浏览器运行测试用例
- 测试 Chrome 扩展程序

## 10 浏览器输入 URL 到页面展示的过程

1、URL 解析
判断是关键字还是 URL，在 chrome 中关键字会被直接搜索

2、DNS 解析

- DNS：把域名和 ip 地址相互映射分布式数据库，让用户能更方便的访问互联网，DNS 协议运行在 UDP 协议之上
- DNS 解析：通过域名最终得到对应 ip 地址的过程。
  1. 首先搜索浏览器自身的 DNS 缓存，有缓存直接返回;
  2. 浏览器自身 DNS 不存在，浏览器就会调用一个类似 gethostbyname 的库函数,此函数会先去检测本地 hosts 文件，查看是否有对应 ip。
  3. 如果本地 hosts 文件不存在映射关系，就会查询路由缓存，路由缓存不存在就去查找本地 DNS 服务器（一般 TCP/IP 参数里会设首选 DNS 服务器，通常是 8.8.8.8)(客户端到本地 DNS 服务器是递归过程）
  4. 如果本地 DNS 服务器还没找到就会向根服务器发出请求。（DNS 服务器之间是迭代过程）

本地 DNS 服务器代我们的浏览器发起迭代 DNS 解析请求，首先它会找根域的 DNS 的 IP 地址（全球 13 台哟，可惜中国没有！）。找到根域的 DNS 地址,就会向其发起请求（请问www.baidu.com这个域名的IP地址是多少呀？）；
根域发现这是一个顶级域 com 域的一个域名，于是告诉本地 DNS 服务器我不知道这个域名的 IP 地址,但是我知道 com 域的 IP 地址，你去找它去吧；
于是本地 DNS 服务器就得到了 com 域的 IP 地址，又向 com 域的 IP 地址发起了请求（请问www.baidu.com这个域名的IP地址是多少呀?）,于是com域服务器告诉本地DNS服务器我不知道www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去;
于是本地 DNS 服务器又向 baidu.com 这个域名的 DNS 地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.baidu.com这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，呀！果真在我这耶，于是就把找到的结果发送给本地DNS服务器;
这个时候本地 DNS 服务器就拿到了www.baidu.com这个域名对应的IP地址。

- DNS 缓存：浏览器，操作系统，路由器，本地 DNS，根域名服务器都会对 DNS 结果作出一定的缓存
- DNS 优化
  - 减少 DNS 请求次数
  - DNS 预获取,DOM 还没开始，浏览器预解析地址，把解析好的地址放在本地缓存里面，DOM 树生成完，要加载图片类的发现 DNS 已经解析好了，再发送请求。<link      rel='dns-prefetch' href='//dfns.tanx.com'>
  - 当客户端 DNS 缓存（浏览器和操作系统）缓存为空时，DNS 查找的数量与要加载的 Web 页面中唯一主机名的数量相同，包括页面 URL、脚本、样式表、图片、Flash 对象等的主机名。减少主机名的数量就可以减少 DNS 查找的数量；
  - 使用 CDN
    - 分流负载
    - 降低延时

DNS 解析后会把域名的解析权交给 cname()指向的内容分发（CDN）专用的 DNS 服务器。CDN 专用的 DNS 服务器把 CDN 的全局负载均衡设备的 ip 地址返回给用户。

3、建立 TCP 链接
TCP 是一种面向连接的，可靠的，基于字节流的传输层通信协议。
建立 TCP 连接需要进行三次握手。过程如下：

- 客户端发送带有 SYN 标识（SYN=1，seq=x）的请求报文段，然后进入 SYN_SEND 状态，等待服务端确认;
- 服务端接收到客户端 SYN 报文段后，需要发送 ACK 信息对这个 SYN 进行确认，同时还要发送自己的 SYN 信息（SYN=1，ACK=1，seq=y，ack=x+1）服务端把这些信息放在一个报文段中（（SYN+ACK 报文段），一并发给客户端，此时客户端进入 SYN_RECV 状态;
- 客户端接收到服务端的 SYN+ACK 报文段后会向服务端发送 ACK（ACK=1，seq=x+，ack=y+1）确认报文段，这个报文段发送后，客户端和服务端都进入 ESTABLISHED 状态，完成三次握手。

双方要明确对方接收能力都是正常的，（客户端发之后，服务端可以确定客户端发送能力正常，服务端发送给客户端，客户端可以确定服务端的接收和发送能力正常，最后客户端发送确认，来确定客户端的接收能力。

4、客户端发送请求
TCP 三次握手建立连接成功后，客户端按照指定的格式开始向服务端发送 HTTP 请求。

5、服务器处理和响应请求

- 请求优化
  - 资源合并压缩
  - 字体图标（精灵图基本不是好的优化方式了，不好维护）
  - base64
  - Gzip（一般文件能压缩 60%）
  - 图片懒加载
  - 数据延迟分批加载
  - CDN 资源

6、浏览器解析并渲染响应内容
将响应的资源发送到客户端

- 渲染过程
  - HTML 解析器:将 HTML 解析成 DOM 树。
  - CSS 解析器: 为 DOM 中各个元素对象计算出样式信息，为布局提供基础设施。
  - JavaScript 引擎:解析并执行 javascript 代码。
  - 布局 layout 模块:在 DOM 树创建后，webkit 需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的模型。
  - 绘图模块:使用图形库将布局计算后的各个网页的节点绘制成图像的结果。

1. 浏览器拿到文件后（拿到的是一些字节码）通过编码方式（一般是 utf-8）转换为对应的字符。
2. 浏览器至上而下解析文档，遇见 HTML 标记，调用 HTML 解析器解析为对应的 tocken，tocken 就是标签文本的序列号，将 tocken 按词法解析解析成具体的标记结构，这个过程已经构建出一颗有标签，有层级，有结构的 DOM 树（就是一块内存，这块内存实际就是一个个 Tocken 构成的）；
3. 遇见 style/link 标记，调用 CSS 解析器处理 CSS 标记并构建 CSSOM 样式树；
4. 遇见 script 标记，调用 javascript 解析器处理，绑定事件、修改 DOM 树/CSS 树等；
5. 将 DOM 树和 CSSOM 树合并成一颗 render 树（渲染树）。
6. 根据渲染树来渲染，计算每个节点的几何信息（这一过程要依赖图形库）；
7. 将各个节点绘制到屏幕上。
   如果用户操作页面，会触发第（6）或者第（7）步骤，也就是重排和重绘

DOM 解析和 CSS 解析是两个并行的线程。不阻塞 DOM 的解析
JS 阻塞
渲染优化

- 标签语义化（使用合适的标签，如果不是 w3c 规定的标签，Tocken 令牌和词法解析语法得识别分析，是不是 wc3 规定的）
- 减少标签嵌套（生成结构树嵌套太多，就得递归（在 DOM 树构建时候快可以一点）
- 样式尽可能少的层级嵌套（使用与编译器的时候，层级嵌套要慎用。CSS 选择器渲染从右到左，.box a{}会 比 a{} 慢
- 尽早把 CSS 下载到客户端（充分利用 HTTP 多请求并发机制）
- 避免阻塞 js 放在底部
- 减少回流
- 放弃传统操作 DOM 时代，基于 vue/react 开始数据影响试图模式
- 样式集中改变
- 缓存布局信息，
- 动画效果应用到 position 属性为 absolute 或 fixed 的元素上（脱离文档流）
- CSS3 硬件加速（比起考虑如何减少回流重绘，更期望不要回流重绘：transform、opacity、filters 这些属性会触发硬件加速，不会引发回流重绘（过多使用占用大量内存，性能- 消耗严重
- 避免使用 table 布局和使用 css 的 js 表达式

7、TCP 四次挥手断开连接

1. 客户端发送标记为 FIN=1（finished 的缩写，表示接收完成，请求释放连接），同时生成一个 Seq=u 的序列号，之后进入 FIN-WAIT-1 半关闭阶段（此时客户端到服务端发送数据的通道已经关闭，但是仍然可以接收服务端发过来的数据）；
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。
3. 客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。
6. 服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态，就结束了这次的 TCP 连接。

## 11 缓存机制

浏览器会先去查看强缓存（Expires 和 cache-control）判断是否过期，如果强缓存生效，直接从缓存中读取资源；若不生效则进行协商缓存(Last-Modified / If-Modified-Since 和 Etag/If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 200，并重新返回资源和缓存标识，再次存入浏览器缓存中；生效则返回 304，并从缓存中读取资源。（协商缓存之前要经过 DNS 域名解析，之后建立 TCP 链接）

输入网址之后，会查找内存缓存，没有再找硬盘，都没有就发生网络请求。
普通刷新（F5）：因为 TAB 没有关闭，所以内存缓存可用，如果匹配上会被优先使用，其次是磁盘缓存
强制刷新（Ctrl+F5）：浏览器不使用缓存，因此发送的请求头均带有 Cache-control：no-cache,服务器直接返回 200 和最新内容。

- Service Worker：浏览器独立线程进行缓存
- Memory Cache：内存缓存
- Disk Cache：硬盘缓存
- Push Cache：推送缓存（HTTP/2 中的）

- Etag（ Entity tag 的缩写，可以理解为“被请求变量的实体值”）
  请求一个资源的时候，服务端给予返回，并且返回了 ETag: "50b1c1d4f775c61:df3" 这样的字样给浏览器，当浏览器再次请求这个资源的时候，浏览器会将 If-None-Match: W/"50b1c1d4f775c61:df3" 传输给服务端，服务端拿到该 ETAG，对比资源是否发生变化，如果资源未发生改变，则返回 304HTTP 状态码，不返回具体的资源。
  "123456789" -- 一个强 ETag 验证符
  W/"123456789" -- 一个弱 ETag 验证符

- Cache-Control

  - public：所有内容都将被缓存（客户端和代理服务器都可缓存）
  - private：所有内容只有客户端可以缓存，Cache-Control 的默认取值
  - no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
  - no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
  - max-age=xxx (xxx is numeric)：缓存内容将在 xxx 秒后失效

- Last-Modified
  Last-Modified: Fri, 12 May 2006 18:53:33 GMT
  客户端第二次请求此 URL 时，根据 HTTP 协议的规定，浏览器会向服务器传送 If-Modified-Since 报头，询问该时间之后文件是否有被修改过：
  If-Modified-Since: Fri, 12 May 2006 18:53:33 GMT
  如果服务器端的资源没有变化，则自动返回 HTTP 304 （Not Changed.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而 保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。

ETag 和 Last-Modified，那么必须同时满足条件才会 304，不存在谁更优先就使用谁一说。
但一般分布式环境下（比如 CDN）很少使用 ETag，因为 ETag 依赖 Web Server 的哈希算法，不同 Web Server、不同版本、不同的配置，都会导致同样的文件 ETag 可能是不相等的。当然了，如果你能限制上述信息都一样，也可以使用 ETag，并不绝对。
先判断 Cache-Control／Expires，再 ETag，最后 Last-Modified，都满足就 304，有一项不满足就 200。
max-age 为 0 表示强制检查 Last-Modified／ETag，可以近似理解为与 no-cache 等效。

## 12 http2 Http3
- 二进制传输
- 多路复用
- 头部压缩
- 服务端推送